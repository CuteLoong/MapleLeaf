#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_shader_atomic_float : enable

#extension GL_GOOGLE_include_directive : require

#include <Misc/Camera.glsl>

layout(local_size_x = 32, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform PushObject {
	float alpha;
    uint  mipLevel;
} object;

layout(set=0, binding=1) uniform sampler2D motionVector;
layout(set=0, binding=2) uniform sampler2D prevMotionVector;
layout(set=0, binding=3) uniform sampler2D MultiLevelLighting;
layout(set=0, binding=4) uniform sampler2D MultiLevelPrevLighting;
// layout(set=0, binding=5) uniform sampler2D depth;
// layout(set=0, binding=6) uniform sampler2D prevDepth;

// layout(set=0, binding=9) writeonly uniform image2D BackwardDepthAlpha2Zero;
// layout(set=0, binding=10) writeonly uniform image2D BackwardDepthAlpha2One;
layout(set=0, binding=11) writeonly uniform image2D BackwardMipColorAlpha2Zero;
layout(set=0, binding=12) writeonly uniform image2D BackwardMipColorAlpha2One;

float cross2d(vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }

vec2 invBilinear(vec2 p, vec2 a, vec2 b, vec2 d, vec2 c) {
    vec2 e = b - a;
    vec2 f = d - a;
    vec2 g = a - b + c - d;
    vec2 h = p - a;

    float k2 = cross2d(g, f);
    float k1 = cross2d(e, f) + cross2d(h, g);
    float k0 = cross2d(h, e);

    float u = 0.0;
    float v = 0.0;

    if(abs(k2) < 0.0001) {
        u = (h.x * k1 + f.x * k0) / (e.x * k1 - g.x * k0);
        v = -k0 / k1;

        // if(u < 0.0 || u > 1.0 || v < 0.0 || v > 1.0) return vec4(-1.0);
    }
    else {
        float w = k1 * k1 - 4.0 * k0 * k2;
        if(w < 0.0) return vec2(-1.0);
        w = sqrt(w);

        float ik2 = 0.5 / k2;
        v = (-k1 - w) * ik2;
        u = (h.x - f.x * v) / (e.x + g.x * v);

        if(u < 0.0 || u > 1.0 || v < 0.0 || v > 1.0) {
            v = (-k1 + w) * ik2;
            u = (h.x - f.x * v) / (e.x + g.x * v);
        }
    }

    return vec2(u, v);
}

vec3 getBlockColor(vec2 screenUV) {
    vec3 blockColor = vec3(0.0f);
    if(screenUV.x < 0.5f && screenUV.y > 0.5f) {
        vec3 lerpC = vec3(mix(0.5f, 1.0f, screenUV.x * 2), mix(0.5f, 1.0f, (screenUV.y - 0.5f) * 2), 0.0f); 
        blockColor = vec3(1.0f, 1.0f, 0.0f) * lerpC;
    }
    else if(screenUV.x > 0.5f && screenUV.y < 0.5f) {
        vec3 lerpC = vec3(0.0f, mix(0.5f, 1.0f, (screenUV.x - 0.5f) * 2), mix(0.5f, 1.0f, screenUV.y * 2));
        blockColor = vec3(0.0f, 1.0f, 1.0f) * lerpC;
    }
    else if(screenUV.x < 0.5f && screenUV.y < 0.5f) {
        vec3 lerpC = vec3(mix(0.5f, 1.0f, screenUV.x * 2), 0.0f, mix(0.5f, 1.0f, screenUV.y * 2));
        blockColor = vec3(1.0f, 0.0f, 1.0f) * lerpC;
    }
    else if(screenUV.x > 0.5f && screenUV.y > 0.5f) {
        float lerpC = mix(0.5f, 1.0f, screenUV.x * 2 - 1.0f);
        blockColor = vec3(1.0f, 1.0f, 1.0f) * lerpC;
    }

    return blockColor;
}

vec2 searchAccuratePixel(vec2 screenUV, vec2 mappedCenter, float weightMV, ivec2 mipSize, int depth) {
    int kernelSize = min(int(mipSize.y >> depth), 5);
    if(kernelSize <= 1) return mappedCenter;

    for(int i = 0; i < kernelSize; i++) {
        for(int j = 0; j < kernelSize; j++) {
            vec2 offset = vec2(i, j) - vec2(kernelSize / 2);
            vec2 curUV = mappedCenter + offset / vec2(mipSize);
            vec2 mv = weightMV > 0 ? texture(prevMotionVector, curUV).xy * weightMV : texture(motionVector, curUV).xy * weightMV;

            vec2 mappedUV = curUV + mv;
            if(abs(mappedUV.x - screenUV.x) < (1 / mipSize.x) && abs(mappedUV.y - screenUV.y) < (1 / mipSize.y)) return curUV;
        }
    }

    return vec2(-1.0f);
}

vec2 searchAccuratePixel(vec2 screenUV,sampler2D motionVectorTexture, float weightMV, ivec2 mipSize, out int findDepth) {
    int depth = 1;
    int missCount = 0;

    vec2 quadBase = vec2(0.0f);
    vec2 res = vec2(-1.0f);

    int maxDepth = min(int(log2(float(mipSize.x))), int(log2(float(mipSize.y))));

    while(depth <= maxDepth) {
        bool outBoundary = false;
        uint quadCount = 1 << depth; // in x and y
        float quadSize = 1 / float(quadCount);
        
        vec2 lt = quadBase + quadSize * vec2(0, 0);
        vec2 rt = quadBase + quadSize * vec2(1, 0);
        vec2 lb = quadBase + quadSize * vec2(0, 1);
        vec2 rb = quadBase + quadSize * vec2(1, 1);

        vec2 lt_mv = texture(motionVectorTexture, lt).xy * weightMV;
        vec2 rt_mv = texture(motionVectorTexture, rt).xy * weightMV;
        vec2 lb_mv = texture(motionVectorTexture, lb).xy * weightMV;
        vec2 rb_mv = texture(motionVectorTexture, rb).xy * weightMV;

        vec2 lt_uv = lt + lt_mv;
        vec2 rt_uv = rt + rt_mv;
        vec2 lb_uv = lb + lb_mv;
        vec2 rb_uv = rb + rb_mv;

        vec2 uv = invBilinear(screenUV, lt_uv, rt_uv, lb_uv, rb_uv);

        if(uv.x >= 0.0 && uv.y >= 0.0 && uv.x <= 1.0 && uv.y <= 1.0) {
            vec4 barycentric = vec4(1 - uv.x - uv.y + uv.x * uv.y, uv.x - uv.x * uv.y, uv.x * uv.y, uv.y - uv.x * uv.y); // vec4(1 - u - v + u * v, u - u * v, u * v, v - u * v)
            res = lt * barycentric.x + rt * barycentric.y + lb * barycentric.w + rb * barycentric.z;
            quadBase = lt;
            findDepth = depth;
            
            depth++;
            outBoundary = true;
            missCount = 0;
        }
        else {
            missCount++;
            ivec2 cur_index = ivec2(lt / quadSize);
            ivec2 offset_index = ivec2(ceil(uv) - 1.0);
            ivec2 next_index = offset_index + cur_index;

            if(next_index.x < 0 || next_index.x >= quadCount || next_index.y < 0 || next_index.y >= quadCount) break;
            outBoundary = true;

            if(missCount >= 4) {
                quadBase = vec2(cur_index + offset_index * 0.5f) * quadSize;
                depth++;
                missCount = 0;
            }
            else quadBase = vec2(next_index) * quadSize;
        }

        if(!outBoundary) break;
    }
    return res;
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 mipSize = ivec2(int(camera.pixelSize.x) >> object.mipLevel, int(camera.pixelSize.y) >> object.mipLevel);

    if(pixel.x >= mipSize.x || pixel.y >= mipSize.y)
        return;

    vec2 screenUV = (vec2(pixel) + vec2(0.5f)) / vec2(mipSize);

    int interpolationDepth = 0;

    vec2 accurateZeroUV = searchAccuratePixel(screenUV, prevMotionVector, object.alpha, mipSize, interpolationDepth);
    accurateZeroUV = searchAccuratePixel(screenUV, accurateZeroUV, object.alpha, mipSize, interpolationDepth);

    vec2 accurateOneUV = searchAccuratePixel(screenUV, motionVector, object.alpha - 1.0, mipSize, interpolationDepth);
    accurateOneUV = searchAccuratePixel(screenUV, accurateOneUV, object.alpha - 1.0, mipSize, interpolationDepth);

    vec3 blockColorZero = getBlockColor(accurateZeroUV);
    vec3 blockColorOne = getBlockColor(accurateOneUV);

    if(accurateZeroUV.x >= 0.0) {
        vec3 accurateColorAlpha2Zero = textureLod(MultiLevelPrevLighting, accurateZeroUV, object.mipLevel).xyz;
        // float accurateDepthAlpha2Zero = texture(prevDepth, accurateZeroUV).r;

        imageStore(BackwardMipColorAlpha2Zero, pixel, vec4(accurateColorAlpha2Zero, 1.0f));
        // imageStore(BackwardDepthAlpha2Zero, pixel, vec4(accurateDepthAlpha2Zero, 0.0f, 0.0f, 1.0f));
    }
    else {
        // imageStore(BackwardDepthAlpha2Zero, pixel, vec4(0.0f));
        imageStore(BackwardMipColorAlpha2Zero, pixel, vec4(0.0f));
    }

    if(accurateOneUV.x >= 0.0) {
        vec3 accurateColorAlpha2One = textureLod(MultiLevelLighting, accurateOneUV, object.mipLevel).xyz;
        // float accurateDepthAlpha2One = texture(depth, accurateOneUV).r;

        imageStore(BackwardMipColorAlpha2One, pixel, vec4(accurateColorAlpha2One, 1.0f));
        // imageStore(BackwardDepthAlpha2One, pixel, vec4(accurateDepthAlpha2One, 0.0f, 0.0f, 1.0f));
    }
    else {
        imageStore(BackwardMipColorAlpha2One, pixel, vec4(0.0f));
        // imageStore(BackwardDepthAlpha2One, pixel, vec4(0.0f));
    }
}