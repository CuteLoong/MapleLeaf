#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_shader_atomic_float : enable

#extension GL_GOOGLE_include_directive : require

#include <Misc/Camera.glsl>

layout(local_size_x = 32, local_size_y = 16, local_size_z = 1) in;

layout(set=0, binding=1) uniform sampler2D radiance;
layout(set=0, binding=2) uniform sampler2D depth;
layout(set=0, binding=3) uniform sampler2D normal;

layout(set=0, binding=4) writeonly uniform image2D RadianceFilterColor;

float luminance(vec3 color) {
    return 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;
}

float gaussian(float x2, float sigma) {
	float sigma2 = sigma * sigma;
	return exp(-(x2) / (2.0f * sigma2));
}

float depth_ddx(sampler2D tex, ivec2 pixel) {
    float current_depth = texelFetch(tex, pixel, 0).r;
    float right_depth = texelFetch(tex, pixel + ivec2(1, 0), 0).r;
    return abs(right_depth - current_depth);
}

float depth_ddy(sampler2D tex, ivec2 pixel) {
    float current_depth = texelFetch(tex, pixel, 0).r;
    float down_depth = texelFetch(tex, pixel + ivec2(0, 1), 0).r;
    return abs(down_depth - current_depth);
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if(pixel.x >= camera.pixelSize.x || pixel.y >= camera.pixelSize.y)
        return;

    vec2 screenUV = (vec2(pixel) + vec2(0.5f)) * camera.pixelSize.zw;

    vec3 radianceColor = texture(radiance, screenUV).xyz;
    float radianceDepth = texture(depth, screenUV).r;
    vec3 radianceNormal = texture(normal, screenUV).xyz;
    float centerLuminance = luminance(radianceColor);

    float ddx = depth_ddx(depth, pixel);
    float ddy = depth_ddy(depth, pixel);

    float totalWeight = 0.0f;
    vec3 filteredColor = vec3(0.0f);

    int dd = 15; // 30 / 2

    for(int i = -dd; i <= dd; i++)
    {
        for(int j = -dd; j <= dd; j++)
        {
            ivec2 offsetPixel = ivec2(clamp(pixel.x + i, 0, camera.pixelSize.x - 1), clamp(pixel.y + j, 0, camera.pixelSize.y - 1));
            float dist2Space = float(i * i + j * j);
            float weightSpace = gaussian(dist2Space, 10.0f); // 30 / 3

            vec3 curColor = texelFetch(radiance, offsetPixel, 0).xyz;

            float curDepth = texelFetch(depth, offsetPixel, 0).r;
            vec3 curNormal = texelFetch(normal, offsetPixel, 0).xyz;
            float curLuminance = luminance(curColor);

            float weightColor = abs(centerLuminance - curLuminance);
            weightColor /= 10.993;
            weightColor = exp(-weightColor);

            float weightNormal = dot(radianceNormal, curNormal);
            weightNormal = clamp(weightNormal, 0.0f, 1.0f);
            weightNormal = pow(weightNormal, 132.30901f);
            weightNormal = max(weightNormal, 0.0f);

            float expectedCurDepth = radianceDepth + ddx * float(i) + ddy * float(j);
            float currentDepthError = abs(curDepth - expectedCurDepth);
            float expectedDifference = abs(radianceDepth - expectedCurDepth) + 1e-6;
            float weightDepth = currentDepthError / expectedDifference * 1.1160001f;
            weightDepth = exp(-weightDepth);

            float weight = weightSpace;
            filteredColor += curColor * weight;
            totalWeight += weight;
        }
    }
    filteredColor /= totalWeight;

    imageStore(RadianceFilterColor, pixel, vec4(filteredColor, 1.0f));
}