#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_shader_atomic_float : enable

#extension GL_GOOGLE_include_directive : require

#include <Misc/Camera.glsl>

layout(local_size_x = 32, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform PushObject {
	float alpha;
} object;

layout(set=0, binding=1) uniform sampler2D motionVector;
layout(set=0, binding=2) uniform sampler2D prevMotionVector;
layout(set=0, binding=3) uniform sampler2D lighting;
layout(set=0, binding=4) uniform sampler2D prevLighting;

layout(set=0, binding=5) writeonly uniform image2D BlockAlpha2Zero;
layout(set=0, binding=6) writeonly uniform image2D BlockAlpha2One;
layout(set=0, binding=7) writeonly uniform image2D BackwardAlpha2Zero;
layout(set=0, binding=8) writeonly uniform image2D BackwardAlpha2One;
layout(set=0, binding=9) writeonly uniform image2D BackwardAccurateAlpha2Zero;
layout(set=0, binding=10) writeonly uniform image2D BackwardAccurateAlpha2One;

struct Block {
    vec2 left_top;
    vec2 right_top;
    vec2 left_bottom;
    vec2 right_bottom;
};

float cross2d(vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }

vec4 invBilinear(vec2 p, vec2 a, vec2 b, vec2 d, vec2 c) {
    vec2 e = b - a;
    vec2 f = d - a;
    vec2 g = a - b + c - d;
    vec2 h = p - a;

    float k2 = cross2d(g, f);
    float k1 = cross2d(e, f) + cross2d(h, g);
    float k0 = cross2d(h, e);

    float u = 0.0;
    float v = 0.0;

    if(abs(k2) < 1e-6) {
        u = (h.x * k1 + f.x * k0) / (e.x * k1 - g.x * k0);
        v = -k0 / k1;

        if(u < 0.0 || u > 1.0 || v < 0.0 || v > 1.0) return vec4(-1.0);
    }
    else {
        float w = k1 * k1 - 4.0 * k0 * k2;
        if(w < 0.0) return vec4(-1.0);
        w = sqrt(w);

        float ik2 = 0.5 / k2;
        v = (-k1 - w) * ik2;
        u = (h.x - f.x * v) / (e.x + g.x * v);

        if(u < 0.0 || u > 1.0 || v < 0.0 || v > 1.0) {
            v = (-k1 + w) * ik2;
            u = (h.x - f.x * v) / (e.x + g.x * v);
        }
    }

    return vec4(1 -u - v + u * v, u - u * v, u * v, v - u * v);
}

vec3 getBlockColor(vec2 screenUV) {
    vec3 blockColor = vec3(0.0f);
    if(screenUV.x < 0.5f && screenUV.y > 0.5f) {
        vec3 lerpC = vec3(mix(0.5f, 1.0f, screenUV.x * 2), mix(0.5f, 1.0f, (screenUV.y - 0.5f) * 2), 0.0f); 
        blockColor = vec3(1.0f, 1.0f, 0.0f) * lerpC;
    }
    else if(screenUV.x > 0.5f && screenUV.y < 0.5f) {
        vec3 lerpC = vec3(0.0f, mix(0.5f, 1.0f, (screenUV.x - 0.5f) * 2), mix(0.5f, 1.0f, screenUV.y * 2));
        blockColor = vec3(0.0f, 1.0f, 1.0f) * lerpC;
    }
    else if(screenUV.x < 0.5f && screenUV.y < 0.5f) {
        vec3 lerpC = vec3(mix(0.5f, 1.0f, screenUV.x * 2), 0.0f, mix(0.5f, 1.0f, screenUV.y * 2));
        blockColor = vec3(1.0f, 0.0f, 1.0f) * lerpC;
    }
    else if(screenUV.x > 0.5f && screenUV.y > 0.5f) {
        float lerpC = mix(0.5f, 1.0f, screenUV.x * 2 - 1.0f);
        blockColor = vec3(1.0f, 1.0f, 1.0f) * lerpC;
    }

    return blockColor;
}

vec2 searchAccuratePixel(vec2 screenUV, vec2 mappedCenter, float weightMV) {
    int kernelSize = 2;

    for(int i = 0; i < kernelSize; i++) {
        for(int j = 0; j < kernelSize; j++) {
            vec2 offset = vec2(i, j) - vec2(kernelSize / 2) + vec2(0.5f);
            vec2 curUV = mappedCenter + offset * camera.pixelSize.zw;
            vec2 mv = weightMV > 0 ? texture(prevMotionVector, curUV).xy * weightMV : texture(motionVector, curUV).xy * weightMV;

            vec2 mappedUV = curUV + mv;
            if(abs(mappedUV.x - screenUV.x) < camera.pixelSize.z && abs(mappedUV.y - screenUV.y) < camera.pixelSize.w) {
                return curUV;
            }
        }
    }

    return vec2(-1.0f);
}

vec2 searchAccuratePixel(vec2 screenUV,sampler2D motionVectorTexture, float weightMV) {
    int depth = 0;
    bool outBoundary = false;
    
    vec2 quadBase = vec2(0.0f);
    vec2 res = vec2(-1.0f);
    while(depth < 10) {
        depth++;
        bool find = false;
        float quadSize = pow(0.5, depth);
        for(int i = 0; i < 4; i++) {
            vec2 lt = quadBase + quadSize * vec2(i % 2, i / 2);
            vec2 rt = quadBase + quadSize * vec2(i % 2 + 1, i / 2);
            vec2 lb = quadBase + quadSize * vec2(i % 2, i / 2 + 1);
            vec2 rb = quadBase + quadSize * vec2(i % 2 + 1, i / 2 + 1);
 
            vec2 lt_mv = texture(motionVectorTexture, lt).xy * weightMV;
            vec2 rt_mv = texture(motionVectorTexture, rt).xy * weightMV;
            vec2 lb_mv = texture(motionVectorTexture, lb).xy * weightMV;
            vec2 rb_mv = texture(motionVectorTexture, rb).xy * weightMV;

            vec2 lt_uv = lt + lt_mv;
            vec2 rt_uv = rt + rt_mv;
            vec2 lb_uv = lb + lb_mv;
            vec2 rb_uv = rb + rb_mv;

            vec4 barycentric = invBilinear(screenUV, lt_uv, rt_uv, lb_uv, rb_uv);
            if(barycentric.x >= 0.0 && barycentric.y >= 0.0 && barycentric.z >= 0.0 && barycentric.w >= 0.0) {
                quadBase = lt;
                find = true;
                res = lt * barycentric.x + rt * barycentric.y + lb * barycentric.w + rb * barycentric.z;
                break;
            }
        }
        if(!find) break;
    }
    return res;
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if(pixel.x >= camera.pixelSize.x || pixel.y >= camera.pixelSize.y)
        return;

    vec2 screenUV = (vec2(pixel) + vec2(0.5f)) * camera.pixelSize.zw;

    vec2 accurateZeroUV = searchAccuratePixel(screenUV, prevMotionVector, object.alpha);
    vec2 accurateOneUV = searchAccuratePixel(screenUV, motionVector, object.alpha - 1.0);
    accurateZeroUV = searchAccuratePixel(screenUV, accurateZeroUV, object.alpha);
    accurateOneUV = searchAccuratePixel(screenUV, accurateOneUV, object.alpha - 1.0);

    vec3 blockColorZero = getBlockColor(accurateZeroUV);
    vec3 blockColorOne = getBlockColor(accurateOneUV);

    if(accurateZeroUV.x >= 0.0) {
        vec3 accurateColorAlpha2Zero = texture(prevLighting, accurateZeroUV).xyz;
        imageStore(BackwardAccurateAlpha2Zero, pixel, vec4(accurateColorAlpha2Zero, 1.0f));
        imageStore(BlockAlpha2Zero, pixel, vec4(blockColorZero, 1.0f));
    }
    else {
        imageStore(BlockAlpha2Zero, pixel, vec4(0.0f));
        imageStore(BackwardAccurateAlpha2Zero, pixel, vec4(0.0f));
    }

    if(accurateOneUV.x >= 0.0) {
        vec3 accurateColorAlpha2One = texture(lighting, accurateOneUV).xyz;
        imageStore(BackwardAccurateAlpha2One, pixel, vec4(accurateColorAlpha2One, 1.0f));
        imageStore(BlockAlpha2One, pixel, vec4(blockColorOne, 1.0f));
    }
    else {
        imageStore(BackwardAccurateAlpha2One, pixel, vec4(0.0f));
        imageStore(BlockAlpha2One, pixel, vec4(0.0f));
    }
}