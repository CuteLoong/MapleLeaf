#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 32, local_size_y = 8) in;

layout(set = 0, binding = 1) uniform sampler2D inDepth;
layout(set = 0, binding = 2) uniform sampler2D inMask;
layout(set = 0, binding = 3) uniform sampler2D inMV;
layout(set = 0, binding = 4) uniform sampler2D inInstanceID;

layout(r32f, set = 0, binding = 5) uniform writeonly image2D thicknessMap;

#include <Misc/Camera.glsl>
#include <Misc/Utils.glsl>

vec3 StereoViewSpacePosAtScreenUVPointDepth(vec2 uv, int viewIndex)
{
    vec3 viewSpaceRay = vec3(camera.invStereoProjection[viewIndex] * (vec4(uv.x * 2.0f - 1.0f, (uv.y * 2.0f - 1.0f) * camera.projectionParams.x, -1.0f, 1.0f) * camera.projectionParams.z));

    float viewOffset = float(viewIndex) * 0.5f;
    float uvx = clamp(uv.x / 2.0f + viewOffset, viewOffset + camera.pixelSize.z, 0.5f + viewOffset - camera.pixelSize.z); // clamp to avoid sampling from the other view, and avoid sampling by linear interpolation
    vec2 screenUV = vec2(uvx, uv.y); // uv is in [0, 1] range, so we need to offset it by half the view index

    float rawDepth = texelFetch(inDepth, ivec2(screenUV * camera.pixelSize.xy), 0).r; 
    return viewSpaceRay * Linear01Depth(rawDepth);
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

    if(pixel.x >= camera.pixelSize.x || pixel.y >= camera.pixelSize.y) return;

    int viewIndex = pixel.x < (camera.pixelSize.x / 2) ? 0 : 1;

    vec2 curEyeUV = (pixel + vec2(0.5f)) * camera.pixelSize.zw;
    int curEyeMask = int(texture(inMask, curEyeUV).r);

    if(curEyeMask == 0) return; // Find out which point the other eye is occluded by
    
    vec2 otherEyeUV = curEyeUV + texelFetch(inMV, pixel, 0).xy;
    int otherEyeMask = int(texture(inMask, otherEyeUV).r);

    if(otherEyeMask == 1) return; // occlude point must can be see by both eyes
    ivec2 otherEyePixel = ivec2(otherEyeUV * camera.pixelSize.xy);

    vec2 curEyeOccluderPointUV = otherEyeUV + texelFetch(inMV, otherEyePixel, 0).xy;
    vec2 occlusionRaySS = curEyeOccluderPointUV - curEyeUV;

    vec3 viewOccluderPosition = StereoViewSpacePosAtScreenUV(vec2(curEyeOccluderPointUV.x * 2.0f - float(viewIndex), curEyeOccluderPointUV.y), viewIndex);
    vec3 viewOccludedPosition = StereoViewSpacePosAtScreenUV(vec2(curEyeUV.x * 2.0f - float(viewIndex), curEyeUV.y), viewIndex);
    vec3 occlusionRayVS = viewOccluderPosition - viewOccludedPosition;

    uint occluderInstanceId = uint(texelFetch(inInstanceID, ivec2(curEyeOccluderPointUV * camera.pixelSize.xy), 0));
    uint occludedInstanceId = uint(texelFetch(inInstanceID, ivec2(curEyeUV * camera.pixelSize.xy), 0));

    if(occluderInstanceId == occludedInstanceId) {
        vec2 stereoOccluderUV =  vec2(curEyeOccluderPointUV.x * 2.0f - float(viewIndex), curEyeOccluderPointUV.y);
        vec2 stereoOccludedUV =  vec2(curEyeUV.x * 2.0f - float(viewIndex), curEyeUV.y);

        float thickness = length(StereoViewSpacePosAtScreenUV(stereoOccluderUV, viewIndex) - StereoViewSpacePosAtScreenUV(stereoOccludedUV, viewIndex));
        imageStore(thicknessMap, otherEyePixel, vec4(thickness, 0.0f, 0.0f, 0.0f));

        return;
    }

    float tOccluder = 1.0f;
    float tOccluded = 0.0f;
    float iteration = 0.0f;

    while(iteration < 10.0f) // wait optimization
    {
        iteration++;
        float t = (tOccluder + tOccluded) * 0.5f;
        vec2 curSampleUV = curEyeUV + occlusionRaySS * t;
        uint curSampleInstanceId = uint(texelFetch(inInstanceID, ivec2(curSampleUV * camera.pixelSize.xy), 0));

        if(curSampleInstanceId == occluderInstanceId)
        {
            tOccluder = t;
        }
        else
        {
            tOccluded = t;
        }
    }
    vec3 viewOccluderEdgePosition = viewOccludedPosition + occlusionRayVS * tOccluder;
    vec2 stereoOccluderEdgeUV =  curEyeUV + occlusionRaySS * tOccluder;

    vec3 tmp = StereoViewSpacePosAtScreenUVPointDepth(vec2(stereoOccluderEdgeUV.x * 2.0f - float(viewIndex), stereoOccluderEdgeUV.y), viewIndex);

    float thickness = length(viewOccluderPosition - viewOccluderEdgePosition);
    imageStore(thicknessMap, otherEyePixel, vec4(thickness, 0.0f, 0.0f, 0.0f));
}