#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct IndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};

layout(set = 0, binding = 0) buffer DrawCommandBuffer 
{
    IndirectCommand commands[];
} drawCommandBuffer;

struct GPUInstanceData
{
    mat4 modelMatrix;
    vec3 AABBLocalMin;
    uint indexCount;
    vec3 AABBLocalMax;
    uint indexOffset;
    uint vertexCount;
    uint vertexOffset;
    uint instanceID;
    uint materialID;
};

layout(set = 0, binding = 1) buffer InstanceDatas
{
    GPUInstanceData instanceData[];
} instanceDatas;

layout(push_constant) uniform PushObject {
    mat4 projection;
    mat4 view;
    vec3 cameraPos;
    vec3 up;
    vec3 forward;
    vec3 right;
    float nearPlane;
    float farPlane;
    float fieldOfView;
    float aspectRatio;
	uint instanceCount;
} object;

vec4 GetPlane(vec3 normal, vec3 point) {
    return vec4(normal.x, normal.y, normal.z, -dot(normal, point));
}

vec4 GetPlane(vec3 a, vec3 b, vec3 c) {
    vec3 normal = -normalize(cross(b-a,c-a));
    return GetPlane(normal, a);
}

//get camera far plane's 4 points
vec3[4] GetCameraFarClipPlanePoint() {
    vec3 points[4]; 

    float distance = object.farPlane;
    float halfFovRad = object.fieldOfView / 2.0;
    float upLen = distance * tan(halfFovRad);
    float rightLen = upLen * object.aspectRatio;

    vec3 farCenterPoint = object.cameraPos + distance * object.forward;
    vec3 up = upLen * object.up;
    vec3 right = rightLen * object.right;

    //2--------3
    //-        -
    //-        -
    //0--------1
    points[0] = farCenterPoint - up - right;
    points[1] = farCenterPoint - up + right;
    points[2] = farCenterPoint + up - right;
    points[3] = farCenterPoint + up + right;

    return points;
}

vec4[6] GetFrustumPlane() {
    vec4 planes[6];

    vec3 camPos = object.cameraPos;
    vec3 points[4] = GetCameraFarClipPlanePoint();

    //clockwise 
    planes[0] = GetPlane(camPos, points[0], points[2]);//left
    planes[1] = GetPlane(camPos, points[3], points[1]);//right
    planes[2] = GetPlane(camPos, points[1], points[0]);//bottom
    planes[3] = GetPlane(camPos, points[2], points[3]);//up
    planes[4] = GetPlane(-object.forward, camPos + object.forward * object.nearPlane);//near
    planes[5] = GetPlane(object.forward, camPos + object.forward * object.farPlane);//far

    return planes;
}

bool IsOutsideThePlane(vec4 plane, vec3 pointPosition)
{
    if(dot(plane.xyz, pointPosition) + plane.w > 0)
        return true;
    return false;
}

void main() {
    int idx = int(gl_GlobalInvocationID.x);
    if (idx >= int(object.instanceCount)) return;

    GPUInstanceData instance = instanceDatas.instanceData[idx];
    IndirectCommand cmd;
    cmd.indexCount = instance.indexCount;
    cmd.instanceCount = 1;
    cmd.firstIndex = instance.indexOffset;
    cmd.vertexOffset = int(instance.vertexOffset);
    cmd.firstInstance = instance.instanceID;

    mat4 M = instance.modelMatrix;
    vec3 boundMin = instance.AABBLocalMin;
    vec3 boundMax = instance.AABBLocalMax;

    vec4[6] planes = GetFrustumPlane();

    vec4 boundVerts[8];
    boundVerts[0] = M * vec4(boundMin, 1);
    boundVerts[1] = M * vec4(boundMax, 1);
    boundVerts[2] = M * vec4(boundMax.x, boundMax.y, boundMin.z, 1);
    boundVerts[3] = M * vec4(boundMax.x, boundMin.y, boundMax.z, 1);
    boundVerts[6] = M * vec4(boundMax.x, boundMin.y, boundMin.z, 1);
    boundVerts[4] = M * vec4(boundMin.x, boundMax.y, boundMax.z, 1);
    boundVerts[5] = M * vec4(boundMin.x, boundMax.y, boundMin.z, 1);
    boundVerts[7] = M * vec4(boundMin.x, boundMin.y, boundMax.z, 1);

    //jugdement
    for (int i = 0; i < 6; i++)
    {
        if(cmd.instanceCount == 0) 
            break;
	    for(int j = 0; j < 8; j++)
	    {
	        vec3 boundPosition = boundVerts[j].xyz;

	        if(!IsOutsideThePlane(planes[i], boundPosition)) 
                break; 
	        if(j == 7)
		        cmd.instanceCount = 0;
	    }
    }

    drawCommandBuffer.commands[idx] = cmd;
}