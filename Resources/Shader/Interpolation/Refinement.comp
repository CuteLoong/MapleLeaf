#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_shader_atomic_float : enable

#extension GL_GOOGLE_include_directive : require

layout(local_size_x = 32, local_size_y = 16, local_size_z = 1) in;

float Luminance(vec3 color) {
    return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

vec3 computeAverageColor(sampler2D texture, vec2 texCoord, vec2 texelSize)
{
    vec3 color = vec3(0.0f);
    for(int y = -1; y <= 1; ++y)
    {
        for(int x = -1; x <= 1; ++x)
        {
            vec2 offset = vec2(x, y) * texelSize;
            color += texture(texture, texCoord + offset).xyz;
        }
    }
    return color / 9.0f;
}

bool detectThinFeatures(sampler2D tex, vec2 pixelCoord, int viewIndex, float threshold) {
    vec3 centerColor = texelFetch(tex, pixelCoord, 0).xyz;
    float centerLuminance = Luminance(centerColor);

    float luminanceMatrix[3][3];

    for(int i = -1; i <= 1; i++) {
        for(int j = -1; j <= 1; j++) {
            vec2 offsetPixel = vec2(clamp(pixelCoord.x + i, camera.pixelSize.x / 2 * viewIndex, camera.pixelSize.x / 2 * (1 + viewIndex) - 1), clamp(pixelCoord.y + j, 0, camera.pixelSize.y - 1));
            
            vec3 color = texelFetch(tex, pixelCoord + offset, 0).xyz;
            luminanceMatrix[i + 1][j + 1] = Luminance(color);
        }
    }

    for(int i = 0; i < 2; i++) {
        for(int j = 0; j < 2; j++) {
            if(abs(centerLuminance - luminanceMatrix[i][j]) < threshold && abs(centerLuminance - luminanceMatrix[i + 1][j]) < threshold && abs(centerLuminance - luminanceMatrix[i][j + 1]) < threshold && abs(centerLuminance - luminanceMatrix[i + 1][j + 1]) < threshold)
                return true;           
        }
    }

    return false;
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if(pixel.x >= camera.pixelSize.x || pixel.y >= camera.pixelSize.y)
        return;

    int viewIndex = pixel.x < (camera.pixelSize.x / 2) ? 0 : 1;

    int pixel

    vec2 screenUV = (vec2(pixel) + vec2(0.5f)) * camera.pixelSize.zw;
    vec2 stereoUV = ScreenUVToStereoUV(screenUV, viewIndex);


}